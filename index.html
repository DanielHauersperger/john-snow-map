<!DOCTYPE html>
<html>

<head>
    <title>Project 1 Daniel Hauersperger</title>
    <script src="https://d3js.org/d3.v3.min.js"></script>
</head>

<style>
    /* css styling from https://bl.ocks.org/d3noob/ccdcb7673cdb3a796e13 */
    body { font: 12px Arial; }

    .axis path,
    .axis line {
        fill: none;
        stroke: grey;
        stroke-width: 1;
        shape-rendering: crispEdges;
    }
</style>    

<body>

    <svg id="map" width="900" height="600">
        <text id='label' x='20' y='20'>Project 1</text>
        <g transform="translate(40,40)"></g>
    </svg>

    <svg id="timeGraph" width="900" height="300">
        <g transform="translate(40,40)"></g>
    </svg>


    <script>
        const MAP_WIDTH = 800,
            MAP_HEIGHT = 400;

        function getScales(streets) {
            // Get the min and max values from the streets array for x and y
            const streets_flat = streets.flat();
            const X_DOMAIN = d3.extent(streets_flat, segment => segment.x),
                Y_DOMAIN = d3.extent(streets_flat, segment => segment.y);

            const xScale = d3.scale.linear()
                .domain(X_DOMAIN).range([0, MAP_WIDTH]);
            const yScale = d3.scale.linear()
                .domain(Y_DOMAIN).range([MAP_HEIGHT, 0]);
            return { xScale, yScale };
        }

        function drawMap(streets, pumps, deaths_age_sex) {
            // Create the (common) scales from the domain of x and y values in streets
            const { xScale, yScale } = getScales(streets);

            drawStreets(streets, xScale, yScale);
            drawPumps(pumps, xScale, yScale);
            drawDeathLocations(deaths_age_sex, xScale, yScale);
        }

        function drawStreets(streets, xScale, yScale) {
            var g = d3.select('#map').select('g');
            g.selectAll('path')
                .data(streets)
                .enter()
                .append('path')
                .attr('d', d => {
                    const start_x = xScale(d[0].x),
                        start_y = yScale(d[0].y);
                    // Start a line at the first vertex
                    let coords = `M ${start_x} ${start_y} `;

                    // for all but the first vertex of this street
                    for (let i = 1; i < d.length; i++) {
                        // add a line from the previous vertex to the current vertex
                        const current_x = xScale(d[i].x),
                            current_y = yScale(d[i].y);
                        coords += `L ${current_x} ${current_y} `;
                    }

                    return coords;
                })
                .attr('stroke', 'black')
                .attr('opacity', 0.6)
                .attr('fill', 'transparent')
        }

        function drawPumps(pumps, xScale, yScale) {
            var g = d3.select('#map').select('g');
            g.selectAll('circle')
                .data(pumps)
                .enter()
                .append('circle')
                .style('fill', 'red')
                .attr('r', 4)
                .attr('stroke', 'black')
                .attr('stroke-width', 1)
                .attr('cx', d => xScale(d.x))
                .attr('cy', d => yScale(d.y));
        }

        function drawDeathLocations(deaths_age_sex, xScale, yScale){
            var g = d3.select('#map').select('g');
            g.selectAll('circle')
                .data(deaths_age_sex)
                .enter()
                .append('circle')
                .style('fill', 'blue')
                .attr('r', 3)
                .attr('stroke', 'black')
                .attr('stroke-width', 1)
                .attr('opacity', 0.5)
                .attr('cx', d => xScale(d.x))
                .attr('cy', d => yScale(d.y));
        }

        function drawTimeGraph(deathdays){
            // Add a key for the parsed date for each row
            deathdays = deathdays.map(day => {
                // This data is from 1854, so I add '-1854' to the end of each date string to specify the year
                return {
                    ...day,
                    date_parsed: d3.time.format("%d-%b-%Y").parse(day.date + '-1854')
                };
            });
                        
            const X_DOMAIN = d3.extent(deathdays, day => day.date_parsed),
                Y_DOMAIN = d3.extent(deathdays, day => day.deaths);

            const xScale = d3.time.scale()
                .domain(X_DOMAIN)
                .range([0, MAP_WIDTH]);
            const xAxis = d3.svg.axis()
                .scale(xScale)
                .ticks(d3.time.day)
                // Display tick label for every other day (surely there is a nicer way to do this)
                // I would have used ticks(d3.time.day, 2), but I wanted the non-labeled days to have tick marks
                .tickFormat(x => {
                    const dayOfYear = d3.time.format("%j")(x);
                    return dayOfYear % 2 == 0 ? "" : d3.time.format("%b %d")(x);
                })
                .orient("bottom");

            var g = d3.select('#timeGraph').select('g');
            g.append("g").attr("class", "x axis")
                .call(xAxis)
                // axis text rotation logic (following three lines) modified from https://stackoverflow.com/a/35449652
                .selectAll('text')
                    .style('text-anchor', 'start')
                    .attr('transform', 'rotate(55 0 12)')
        }

        // This loading logic is ugly, but I'm using D3 v3 for this class and the fetch API 
        // isn't supported until v5 (see https://stackoverflow.com/a/49604124)
        d3.json('streets.json', function (streets) {
            d3.csv('pumps.csv', function (pumps) {
                d3.csv('deaths_age_sex.csv', function (deaths_age_sex) {
                    d3.csv('deathdays.csv', function(deathdays){
                        drawMap(streets, pumps, deaths_age_sex);
                        drawTimeGraph(deathdays);
                    })
                })
            })
        })

    </script>
</body>


</html>
