<!DOCTYPE html>
<html>

<head>
    <title>Project 1 Daniel Hauersperger</title>
    <script src="https://d3js.org/d3.v3.min.js"></script>
</head>

<style>
    /* below css styling from https://bl.ocks.org/d3noob/ccdcb7673cdb3a796e13 */
    body { font: 12px Arial; }

    .axis path,
    .axis line {
        fill: none;
        stroke: grey;
        stroke-width: 1;
        shape-rendering: crispEdges;
    }

    /* below css styling modified from https://stackoverflow.com/a/46861080 */
    .selected {
        fill: steelblue;
        opacity: 1;
        fill-opacity: 1;
    }

    .axis {
        font: 12px Arial;
    }

    .extent {
        stroke: white;
        opacity: .125;
        shape-rendering: crispEdges;
    }
</style>    

<body>

    <svg id="map" width="900" height="600">
        <text id='label' x='20' y='20'>Project 1</text>
        <g transform="translate(40,40)"></g>
    </svg>

    <svg id="timeGraph" width="900" height="300">
        <g transform="translate(40,40)"></g>
    </svg>


    <script>
        const MAP_WIDTH = 800,
            MAP_HEIGHT = 400,
            TIME_GRAPH_HEIGHT = 200,
            BAR_WIDTH = 12;

        function getMapScales(streets) {
            // Get the min and max values from the streets array for x and y
            const streets_flat = streets.flat();
            const X_DOMAIN = d3.extent(streets_flat, segment => segment.x),
                Y_DOMAIN = d3.extent(streets_flat, segment => segment.y);

            const xScale = d3.scale.linear()
                .domain(X_DOMAIN).range([0, MAP_WIDTH]);
            const yScale = d3.scale.linear()
                .domain(Y_DOMAIN).range([MAP_HEIGHT, 0]);
            return { xScale, yScale };
        }

        function drawMap(streets, pumps, deaths_age_sex_date) {
            // Create the (common) scales from the domain of x and y values in streets
            const { xScale, yScale } = getMapScales(streets);

            drawStreets(streets, xScale, yScale);
            drawPumps(pumps, xScale, yScale);
            const updateDeathLocations = drawDeathLocations(deaths_age_sex_date, xScale, yScale);
            return updateDeathLocations;
        }

        function drawStreets(streets, xScale, yScale) {
            var g = d3.select('#map').select('g');
            g.selectAll('path')
                .data(streets)
                .enter()
                .append('path')
                .attr('d', d => {
                    const start_x = xScale(d[0].x),
                        start_y = yScale(d[0].y);
                    // Start a line at the first vertex
                    let coords = `M ${start_x} ${start_y} `;

                    // for all but the first vertex of this street
                    for (let i = 1; i < d.length; i++) {
                        // add a line from the previous vertex to the current vertex
                        const current_x = xScale(d[i].x),
                            current_y = yScale(d[i].y);
                        coords += `L ${current_x} ${current_y} `;
                    }

                    return coords;
                })
                .attr('stroke', 'black')
                .attr('opacity', 0.6)
                .attr('fill', 'transparent')
        }

        function drawPumps(pumps, xScale, yScale) {
            var g = d3.select('#map').select('g');
            g.selectAll('circle.pump')
                .data(pumps)
                .enter()
                .append('circle')
                .style('fill', 'red')
                .attr('r', 4)
                .attr('stroke', 'black')
                .attr('stroke-width', 1)
                .attr('cx', d => xScale(d.x))
                .attr('cy', d => yScale(d.y))
                .attr('class', 'pump');
        }

        function drawDeathLocations(deaths_age_sex_date, xScale, yScale) {
            // draw all death locations at first, and return a function to show/hide
            // them based on what times are selected
            var g = d3.select('#map').select('g');
            const deathLocations = g.selectAll('circle.deathLocation')
                .data(deaths_age_sex_date)
                .enter()
                .append('circle')
                .attr('fill', 'steel-blue')
                .attr('r', 3)
                .attr('stroke', 'black')
                .attr('stroke-width', 1)
                .attr('opacity', 0.1)
                .attr('cx', d => xScale(d.x))
                .attr('cy', d => yScale(d.y))
                .attr('class', 'deathLocation');
            deathLocations.append("title") // tooltip
                .text(d => `Age: ${d.age}\nSex: ${d.sex}`);
            
            const updateDeathLocations = function(extent){
                deathLocations.classed('selected', d => { return extent[0] <= d.date_parsed && d.date_parsed <= extent[1]; });
            }
            return updateDeathLocations;
        }

        function drawTimeGraph(deathdays, updateFunctions) {                        
            const X_DOMAIN = d3.extent(deathdays, day => day.date_parsed),
                Y_DOMAIN = d3.extent(deathdays, day => day.deaths_num);

            const xScale = d3.time.scale()
                .domain(X_DOMAIN)
                .range([0, MAP_WIDTH]);
            const yScale = d3.scale.linear()
                .domain(Y_DOMAIN)
                .range([0, TIME_GRAPH_HEIGHT]);
            const xAxis = d3.svg.axis()
                .scale(xScale)
                .ticks(d3.time.day)
                // Display tick label for every other day (surely there is a nicer way to do this)
                // I would have used ticks(d3.time.day, 2), but I wanted the non-labeled days to have tick marks too
                .tickFormat(x => {
                    const dayOfYear = d3.time.format('%j')(x);
                    return dayOfYear % 2 == 0 ? '' : d3.time.format('%b %d')(x);
                })
                .orient('bottom');

            var g = d3.select('#timeGraph').select('g');

            // brushing logic below (~45 lines) is modified from https://stackoverflow.com/a/46861080
            // the idea to call all passed update functions in brushed() was mine though :) 
            const brush = d3.svg.brush()
                .x(xScale)
                .extent(X_DOMAIN) // default extent to the full domain
                .on('brush', brushed)

            const bar = g.append('g')
                .attr('fill-opacity', 0.2)
                .selectAll('rect')
                .data(deathdays)
                .enter()
                .append('rect')
                .attr('height', d => yScale(d.deaths_num))
                .attr('width', BAR_WIDTH)
                .attr('x', d => xScale(d.date_parsed) - BAR_WIDTH/2)
                .attr('y', d => TIME_GRAPH_HEIGHT - yScale(d.deaths_num));

            const brushContainer = g.append('g')
                .attr('class', 'brush')
                .call(brush)
                .call(brush.event);

            brushContainer.selectAll('rect')
                .attr('height', TIME_GRAPH_HEIGHT);

            brushContainer.selectAll('.background')
                .on('mousedown', beforebrushed, true)
                .on('touchstart', beforebrushed, true);

            function brushed() {
                const extent = brush.extent();

                bar.classed('selected', d => { return extent[0] <= d.date_parsed && d.date_parsed <= extent[1]; });
                
                // I didn't like the idea of this function containing the logic for updating other graphs, since I 
                // would have to update it when I add more dependent graphs. So instead just call any passed update functions 
                for(const f of updateFunctions){
                    f(extent);
                }
            }

            function beforebrushed() {
                d3.event.stopImmediatePropagation();

                brushContainer.transition()
                    .duration(700)
                    .call(brush.extent(X_DOMAIN))
                    .call(brush.event);
            }

            g.append('g').attr('class', 'x axis')
                .call(xAxis)
                .attr('transform', `translate(0, ${TIME_GRAPH_HEIGHT})`)
                // axis text rotation logic (following three lines) modified from https://stackoverflow.com/a/35449652
                .selectAll('text')
                    .style('text-anchor', 'start')
                    .attr('transform', 'rotate(55 0 12)')
        }

        function parseDeathdays(deathdays) {
            // Add keys for the parsed date and deaths as a number to each row
            return deathdays.map(day => {
                // This data is from 1854, so I add '-1854' to the end of each date string to specify the year
                return {
                    ...day,
                    date_parsed: d3.time.format('%d-%b-%Y').parse(day.date + '-1854'),
                    deaths_num: +day.deaths
                };
            });
        }

        function addDeathDate(deaths_age_sex, deathdays_parsed) {
            const deaths_age_sex_date = [];
            // deaths_age_sex is in order of each date of death
            let i = 0;
            for (const deathDay of deathdays_parsed){
                let rows_added = 0;
                while(rows_added < deathDay.deaths_num){
                    deaths_age_sex_date.push({
                        ...deaths_age_sex[i],
                        sex: (+deaths_age_sex[i].gender ? 'Female' : 'Male'), // assignment specified gender=1 is female, gender=0 is male
                        date_parsed: deathDay.date_parsed
                    });
                    i++;
                    rows_added++;
                }
            }

            return deaths_age_sex_date;
        }

        // This loading logic is ugly, but I'm using D3 v3 for this class and the fetch API 
        // isn't supported until v5 (see https://stackoverflow.com/a/49604124)
        d3.json('streets.json', function (streets) {
            d3.csv('pumps.csv', function (pumps) {
                d3.csv('deaths_age_sex.csv', function (deaths_age_sex) {
                    d3.csv('deathdays.csv', function(deathdays) {
                        // clean and join the data
                        const deathdays_parsed = parseDeathdays(deathdays);
                        const deaths_age_sex_date = addDeathDate(deaths_age_sex, deathdays_parsed);

                        // now draw the map and graph
                        const updateDeathLocations = drawMap(streets, pumps, deaths_age_sex_date);
                        drawTimeGraph(deathdays_parsed, [updateDeathLocations]);
                    })
                })
            })
        })

    </script>
</body>


</html>
